var store = [{
        "title": "[ALGORITHM]BOJ14890-경사로",
        "excerpt":"문제   크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.   오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.   다음과 같은 N=6인 경우 지도를 살펴보자.      이때, 길은 총 2N개가 있으며, 아래와 같다.      길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.      경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.   낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.   경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.   아래와 같은 경우에는 경사로를 놓을 수 없다.      경사로를 놓은 곳에 또 경사로를 놓는 경우   낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우   낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우   경사로를 놓다가 범위를 벗어나는 경우   L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.      경사로를 놓을 수 없는 경우는 아래와 같다.      위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.   가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.      지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.   출력   첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.   예제 입력 1   6 2 3 3 3 3 3 3 2 3 3 3 3 3 2 2 2 3 2 3 1 1 1 2 2 2 1 1 1 3 3 1 1 1 2 3 3 2   예제 출력 1   3   예제 입력 2   6 2 3 2 1 1 2 3 3 2 2 1 2 3 3 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 2 2   예제 출력 2   7   예제 입력 3   6 3 3 2 1 1 2 3 3 2 2 1 2 3 3 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 2 2   예제 출력 3   3   예제 입력 4   6 1 3 2 1 1 2 3 3 2 2 1 2 3 3 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 2 2   예제 출력 4   11   힌트   예제 2의 경우 아래와 같은 초록색 길을 지나갈 수 있다.      예제 3의  경우에는 아래와 같은 초록색 길이 지나갈 수 있는 길이다.      마지막으로, 예제 4의 경우에는 아래와 같은 초록색 길이 지나갈 수 있는 길이다.      나의 코드 ver.1   import java.io.InputStreamReader; import java.util.Scanner;  public class Main {     static int[][] map;     static boolean[][] visited1;     static boolean[][] visited2;     static int N;// 지도 길이     static int L;// 경사로 길이      public static void main(String[] args) {         Scanner scanner = new Scanner(new InputStreamReader(System.in));          N = scanner.nextInt();         L = scanner.nextInt();         map = new int[N][N];         visited1 = new boolean[N][N];         visited2 = new boolean[N][N];          for (int i = 0; i &lt; N; i++) {             for (int j = 0; j &lt; N; j++) {                 map[i][j] = scanner.nextInt();             }         }          int answer = 0;         //가로 검사         for (int i = 0; i &lt; N; i++) {             int pre = map[i][0];             answer++;             for (int j = 1; j &lt; N; j++) {                 if (pre != map[i][j]) {                     if (pre - map[i][j] &lt; 0) {//오르막                         if (!upper(map[i][j], j, i, 0)) {                             answer--;                             break;                         }                     } else {//내리막                         if (!lower(map[i][j - 1], j-1, i, 0)) {                             answer--;                             break;                         } else {//성공                             j += L - 1;                         }                     }                 }                 pre = map[i][j];             }         }          //세로 검사         for (int j = 0; j &lt; N; j++) {             int pre = map[0][j];             answer++;             for (int i = 1; i &lt; N; i++) {                 if (pre != map[i][j]) {                     if (pre - map[i][j] &lt; 0) {//오르막                         if (!upper(map[i][j], j, i, 1)) {                             answer--;                             break;                         }                     } else {//내리막                         if (!lower(map[i - 1][j], j, i - 1, 1)) {                             answer--;                             break;                         } else {//성공                             i += L - 1;                         }                     }                 }                 pre = map[i][j];             }         }         System.out.print(answer);     }      //dir:0 - 가로방향, dir:1 - 세로방향     public static boolean upper(int cur, int x, int y, int dir) {//오르막 경사         if (dir == 0) {             if (x - L &lt; 0) return false;             for (int i = 1; i &lt;= L; i++) {                 if (map[y][x - i] != cur - 1 || visited1[y][x - i]) return false;                 visited1[y][x - i] = true;             }         } else {             if (y - L &lt; 0) return false;             for (int i = 1; i &lt;= L; i++) {                 if (map[y - i][x] != cur - 1 || visited2[y - i][x]) return false;                 visited2[y - i][x] = true;             }         }         return true;     }      public static boolean lower(int cur, int x, int y, int dir) {//내리막 경사로         if (dir == 0) {             if (x + L &gt;= N) return false;             for (int i = 1; i &lt;= L; i++) {                 if (map[y][x + i] != cur - 1 || visited1[y][x + i]) return false;                 visited1[y][x + i] = true;             }         } else {             if (y + L &gt;= N) return false;             for (int i = 1; i &lt;= L; i++) {                 if (map[y + i][x] != cur - 1 || visited2[y + i][x]) return false;                 visited2[y + i][x] = true;             }         }         return true;     } }      먼저 나는 크게 가로검사/ 세로검사로 나누었다.   다시 가로(세로)인 경우 👉 오르막 경사/ 내리막 경사인 경우를 또 나누었다.            오르막인지 내리막인지는 if (pre - map[ i ][ j ] &lt; 0) 으로, 이전보다 현재 값이 크면 오르막, 반대는 내리막을 실행시켰다.           항상 answer++을 해주었고, 만약에 오르막, 내리막을 실패할 경우는 -1해서 답을 얻었다.   upper 와 lower함수는 경사로를 놓을 수 있는지 없는지를 판별해주는 함수다. 이를 세로인 경우, 가로인 경우를 나눠서 작성했다. 나누지 않고 할 수 있는지 고민해봐야겠다.   visited를 사용하지 않았었는데, 332233(L=2)인 경우 true가 나왔다. 22인 부분을 경사로 세워준것을 표시하기 위해 visited를 사용하였다. 이를 visited 2개 사용한 점이 아쉽다.   까탈스러웠던 부분은 index로 하는거다 보니 많이 어려웠다.   느낀점   빨리 풀고 싶어서 생각을 많이 하지 않고 바로 코드 부터 쳤다. 그러다 보니 작성하면서도 비슷한 것들이 많아서 좀만 고민을 더 해보면 짧게 할 수 있겠다? 라는 생각이 들었다. 아무튼 오늘은 풀었으니 좀 더 바꾸는 것은 다음에 할 것이다‼️첫 삼성 문제였는데 역시 길다! 나만 길수도! 아무튼 풀고 나니 뿌듯하다.      문제: https://www.acmicpc.net/problem/14890   저장소: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/3.SWEA/Q_14890_경사로.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","삼성코테","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ14890_%EA%B2%BD%EC%82%AC%EB%A1%9C/",
        "teaser":null},{
        "title": "[Study]NVM & Node 설치 기록",
        "excerpt":"[React Native로 날씨앱 만들기]를 하기에 앞서 먼저 개발 환경을 설치하고자 한다.   📌 설치할 것           Node.js -&gt; 10이상            npn(Node Version Manager) -&gt; 6이상            시뮬레이터 -&gt; 안드로이드 스튜디오, xcode            iOS, Android 앱 엑스포 폰에 설치       https://apps.apple.com/kr/app/expo-client/id982107779       👉 iOS, 안드로이드 앱 expo가 테스트 할 수 있는 유일한 방법(휴대폰에서)            ‼️설치 완료 후       npm install -g expo-cli           NPM설치   🧐참고로 NPM은 Node Version Manager의 줄임말 !           설치       $ sudo curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash                확인       $ nvm ls     -bash: nvm: command not found //이렇게 뜬다.                터미널을 종료했다가 다시 켠다.            확인       $ vi ~/.bash_profile           export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" # This loads nvm //이 코드가 있는지 확인 한다.                다시 종료했다가 켠다.(종료 했다 켜는건 만병통치)       source ~/.bash_profile                설치 확인       $ nvm ls           //결과             N/A node -&gt; stable (-&gt; N/A) (default) iojs -&gt; N/A (default)           Node 설치           설치       $ nvm install 6.10.1 //가장 안정화된 버전이라고 한다.                확인       $ nvm ls           -&gt;      v6.10.1 default -&gt; 6.10.1 (-&gt; v6.10.1) node -&gt; stable (-&gt; v6.10.1) (default) stable -&gt; 6.10 (-&gt; v6.10.1) (default) iojs -&gt; N/A (default) lts/* -&gt; lts/erbium (-&gt; N/A) lts/argon -&gt; v4.9.1 (-&gt; N/A) lts/boron -&gt; v6.17.1 (-&gt; N/A) lts/carbon -&gt; v8.17.0 (-&gt; N/A) lts/dubnium -&gt; v10.18.0 (-&gt; N/A) lts/erbium -&gt; v12.14.0 (-&gt; N/A)                노드 버전 확인       $ node -v           v6.10.1           다른 Node 버전 설치           설치       $ nvm install 12.1.0           니꼴라스 따라서 같은 버전 설치함            확인       👉 node -v v12.1.0 👉 npm -v 6.9.0                터미널 시작시 노드 기본 버전설정       nvm alias default v12.14.0     //결과 default -&gt; v12.14.0           ","categories": ["Study"],
        "tags": ["Study","NVM","node.js"],
        "url": "http://localhost:4000/study/Study-NVM&Node%EC%84%A4%EC%B9%98%EB%B0%A9%EB%B2%95/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1541-잃어버린괄호",
        "excerpt":"문제   세준이는 양수와 +, -, 그리고 괄호를 가지고 길이가 최대 50인 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.   그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.   괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.   입력   첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다.   출력   첫째 줄에 정답을 출력한다.   예제 입력 1   55-50+40   예제 출력 1   -35   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] input = bufferedReader.readLine().split(\"-\");         int answer = innerCal(input[0]);         for (int i = 1; i &lt; input.length; i++){             answer -= innerCal(input[i]);         }         System.out.println(answer);     }      public static int innerCal(String str){         String[] input = str.split(\"\\\\+\");         int sum = 0;          for (int i = 0; i &lt; input.length; i++){             sum += Integer.parseInt(input[i]);         }         return sum;     } }            ‘최소값’을 만들어야 하기 때문에 최대한 - 가 많아야 한다.       👉 그러기 위해서는 - 부터 다음 - 전까지 괄호를 묶으면 그 괄호 안에 값들은 -를 갖게 된다.            따라서 나는 입력을 받을 때 - 로 분리해서 받았다.            그리고 그 분리된 것들끼리 - 로 더해서 answer에 더해주었다.              이때 중요한 것은 시작은 항상 + 이므로 첫번째 분리된 것은 - 를 붙여주면 안된다 !           느낀점   2달만에 다시 풀었던 문젠데 코드가 아주 거의 비슷하다. 웃겼던거는   이번에 answer += innerCal(input[i]) * -1; 로 썼다는 것이다. 그래서 이전에 했던 코드를 보고   answer -= innerCal(input[i]); 고쳤다 키키 !      문제 : https://www.acmicpc.net/problem/1541   저장소1 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1541_잃어버린괄호.java   저장소2 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1541_잃어버린괄호_ver2.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","Greedy","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1541_%EC%9E%83%EC%96%B4%EB%B2%84%EB%A6%B0%EA%B4%84%ED%98%B8/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1700-멀티탭 스케줄링",
        "excerpt":"문제   기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다. 준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을 사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다. 그래서 준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고, 이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.   예를 들어 3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면,      키보드   헤어드라이기   핸드폰 충전기   디지털 카메라 충전기   키보드   헤어드라이기   키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음 디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다.   입력   첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 100)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 100)가 정수로 주어진다. 두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다.   출력   하나씩 플러그를 빼는 최소의 횟수를 출력하시오.   예제 입력 1   2 7 2 3 2 3 1 2 7   예제 출력 1   2   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.*;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] input = bufferedReader.readLine().split(\" \");         int N = Integer.parseInt(input[0]);//멀티탭구멍수         int K = Integer.parseInt(input[1]);//사용횟수         int[] arr = new int[K];         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();         HashSet&lt;Integer&gt; multi = new HashSet&lt;&gt;();         int answer = 0;          String[] str = bufferedReader.readLine().split(\" \");         for (int i = 0; i &lt; K; i++) {             arr[i] = Integer.parseInt(str[i]);             arrayList.add(Integer.parseInt(str[i]));         }          for (int i = 0; i &lt; K; i++) {             if (multi.contains(arr[i]) || multi.size() &lt; N) {                 multi.add(arr[i]);             } else {                 answer++;                 int index = Integer.MIN_VALUE;                  for (int cur : multi) {                     if (arrayList.subList(i + 1, K).contains(cur)) {                         int position = arrayList.subList(i + 1, K).indexOf(cur) + i + 1;                         index = Math.max(position, index);                     } else {                         multi.remove(cur);                         break;                     }                 }                 if (multi.size() == N) {                     multi.remove(arr[index]);                 }                 multi.add(arr[i]);             }         }         System.out.println(answer);     } }            먼저 multi라는 hashSet을 만들어 주었다.       👉 hashSet은 key값의 중복을 막고, key가 존재하는지 안하는지 판단하기 때문에 이 자료형을 사용하였다.       만약, multi라는 hash에 값이 없거나, 꽉 채워지지 않았다면 현재 스케줄을 넣는다.       if (multi.contains(arr[i]) || multi.size() &lt; N) {   multi.add(arr[i]);//존재 하더라고 add를 해도 중복되지 않기 때문에 그냥 add해줬다. }                 만약 multi가 꽉찼을 경우, 어떤 한개를 빼고 새로운 것을 넣어야 한다.                       여기서 어떤 것을 뺄지 중요하다.           👉 그리디하게 뺀다면 앞으로 나오지 않는 것이나 or 나올려면 가장 먼것을 빼는 것이 맞다 ‼️                        그래서 multi에 있는 키를 가져와 앞으로 나오지 않는 것이나, 가장 먼 것을 빼주었다.       for (int cur : multi) {   if (arrayList.subList(i + 1, K).contains(cur)) {//1. 뒤에 배열중 해당 키 값이 존재할 때     int position = arrayList.subList(i + 1, K).indexOf(cur) + i + 1;     //arr에서의 위치를 찾는다. 자른 배열이기 때문에 현재 위치를 더해줘야지 해당 위치가 제대로 나온다.     index = Math.max(position, index);     //존재하는 것중 가장 먼 것을 저장한다.   } else {// 2. 뒤에 배열중 해당 키값이 존재하지 않을 때 -&gt; 그것을 hash에서 빼주면 된다.     multi.remove(cur);//해당 것 제거     break;   } } //2의 경우를 통과했을 시 multi는 1개가 줄었을 것이니 이 과정을 생략하기 위해서 if 문 사용했다. if (multi.size() == N) {   multi.remove(arr[index]); } multi.add(arr[i]);           👉 이때 ArrayList의 subList로 뒤에 배열 중에서 comtains(key) 를 사용하여서 해당 키값들이 존재하는 곳들중 가장 먼 위치를 저장한다.       느낀점   진짜 집중해서 한시간동안 풀었던거 같다. 처음에는 multi라는 것을 배열로 생각하다 보니 하나하나 검사하는게 어려웠고 hash를 떠올리게 되었다. 그리고 뒤에 배열중 아이템이 어디 인덱스에 있는지 찾는 것을 배열에서 하나하나 검사하려다가 subList로 잘라서 IndexOf를 사용해서 찾았다. 이 두개를 사용하지 않았으면 어떻게든 짰을 수 있겠지만 어려웠을 거 같다 ‼️ 아무튼 이거 정말 내 기준 고난도 문제였다.      문제 : https://www.acmicpc.net/problem/1700   저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1700_멀티탭스케줄링.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","Greedy","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1700_%EB%A9%80%ED%8B%B0%ED%83%AD%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1931-회의실배정",
        "excerpt":"문제   한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의들에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 최대수의 회의를 찾아라. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.   입력   첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.   출력   첫째 줄에 최대 사용할 수 있는 회의 수를 출력하여라.   예제 입력 1   11 1 4 3 5 0 6 5 7 3 8 5 9 6 10 8 11 8 12 2 13 12 14   예제 출력 1   4   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Arrays; import java.util.Comparator;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         int N = Integer.parseInt(bufferedReader.readLine());         int[][] map = new int[N][2];          for (int i = 0; i &lt; N; i++) {             String[] input = bufferedReader.readLine().split(\" \");             map[i][0] = Integer.parseInt(input[0]);             map[i][1] = Integer.parseInt(input[1]);         }          Arrays.sort(map, new Comparator&lt;int[]&gt;() {             @Override             public int compare(int[] o1, int[] o2) {                 if (o1[1] == o2[1]) return o1[0] - o2[0];                 return o1[1] - o2[1];             }         });          int answer = 0;         int cur = -1;          for (int i = 0; i &lt; N; i++) {             if (cur &lt;= map[i][0]) {                 answer++;                 cur = map[i][1];             }         }         System.out.println(answer);     } }           이 문제의 요점은 어떻게 하면 가장 많은 회의를 할 수 있을 지다.                       회의시작 빠른 순                        회의 짧은 순                        회의 일찍 끝나는 순 ✔️           👉 가장 빨리 끝나는 회의를 고려한다면 그만큼 뒤에 회의가 많이 남아 있는 것 !!                        아무튼 위에 것을 떠올린다면 구현은 간단하다.                       회의의 종료시간으로 정렬을 해야한다.           👉 이때 이차원 배열의 특정 기준으로 정렬을 해야하기 때문에 comparator를 구현할줄 알아야 한다!                        ‘한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.’ 라는 조건이 있다                                   [1,1] [2,2] [1,2] 가 있다면 종료시간만 고려해서 정렬을 하게 된다면 [1,1] [2,2] [1,2] 일 것이다. 그러면 총 2번의 회의가 가능 하다.               하지만, [1,1] [1,2] [2,2] 로 된다면 총 3번의 회의가 가능하다!               👉 따라서 만약에 끝나는 시간이 같은 경우에는 시작 시간 순으로 정렬을 하도록 하였다.               Arrays.sort(map, new Comparator&lt;int[]&gt;() {             @Override             public int compare(int[] o1, int[] o2) {                 if (o1[1] == o2[1]) return o1[0] - o2[0];//종료시간 같을 경우                 return o1[1] - o2[1];             }         });                                                   느낀점   이제 Comparator을 스스로 구현할 수 있어서 뿌듯하다! 아직도 o1-o2이거 순서는 헷갈리기는 하지만 ❗️아무튼 오름차순은 o1-o2로 기억하기!      문제: https://www.acmicpc.net/problem/1931   저장소: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1931_회의실배정_ver2.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","Greedy","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1931_%ED%9A%8C%EC%9D%98%EC%8B%A4%EB%B0%B0%EC%A0%95/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ2875-대회or인턴",
        "excerpt":"문제   백준대학교에서는 대회에 나갈 때 2명의 여학생과 1명의 남학생이 팀을 결성해서 나가는 것이 원칙이다. (왜인지는 총장님께 여쭈어보는 것이 좋겠다.)   백준대학교는 뛰어난 인재들이 많아 올해에도 N명의 여학생과 M명의 남학생이 팀원을 찾고 있다.   그런데 올해에는 대회에 참여하려는 학생들 중 K명을 반드시 인턴쉽 프로그램에 참여하라는 학교의 방침이 생기게 되었다. 인턴쉽에 참여하는 학생은 대회에 참여하지 못한다.   백준대학교에서는 뛰어난 인재들이 많기 때문에, 많은 팀을 만드는 것이 최선이다.   여러분은 N명의 여학생과 M명의 남학생, K명의 인턴쉽에 참여해야하는 인원이 주어질 때 만들 수 있는 최대의 팀 수를 구하면 된다.   입력   첫째 줄에 N, M, K가 순서대로 주어진다. (0 ≤ M ≤ 100), (0 ≤ N ≤ 100), (0 ≤ K ≤ M+N),   출력   만들 수 있는 팀의 최댓값을 출력하면 된다.   예제   6 3 2   예제   2   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] input = bufferedReader.readLine().split(\" \");         int N = Integer.parseInt(input[0]);         int M = Integer.parseInt(input[1]);         int K = Integer.parseInt(input[2]);         int total = N + M;          int team = M;         while (true){             if (K &lt;=total-3*team &amp;&amp; team*2 &lt;= N) break;             team --;         }         System.out.println(team);     } }           먼저 나올수 있는 팀의 수의 가장 max값은 남학생 수라고 생각을 했다.       남학생1명, 여학생2명이 한 팀이기 때문에 !            다음은 while문을 돌면서                       팀에 속하지 않은 학생이 인턴수보다 커야한다.           K &lt;=total-3*team                        남학생을 기준으로 팀을 계산했기 때문에 여학생도 이 것에 부합해야 한다.           따라서, team*2 &lt;= N 을 해주었다.           👉 위 조건에 만족을 하면 break, 만족하지 못하면 team을 1개씩 줄여 나갔다.                   느낀점   2달만에 다시 풀었던 문젠데 그때는 어렵게 생각해서 팀 수를 나눠서 계산했던거 같다. 하지만 이번에는 간단하게 생각해서 쉽게 나온거 같다!      문제 : https://www.acmicpc.net/problem/2875   저장소1 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2875_대회or인턴.java   저장소2 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2875_대회or인턴_ver2.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","Greedy","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ2875_%EB%8C%80%ED%9A%8Cor%EC%9D%B8%ED%84%B4/",
        "teaser":null},{
        "title": "[ALGORITHM]Programmers-단속카메라",
        "excerpt":"문제   고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.   고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.   제한사항      차량의 대수는 1대 이상 10,000대 이하입니다.   routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다.   차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다.   차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.   입출력 예                  routes       return                       [[-20,15], [-14,-5], [-18,-13], [-5,-3]]       2           입출력 예 설명   -5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다.   -15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.   나의 코드   ver1   class Solution {     public static int solution(int[][] routes) {         int answer = 1;          Arrays.sort(routes, new Comparator&lt;int[]&gt;() {             @Override             public int compare(int[] o1, int[] o2) {                 Integer route1 = o1[0];                 Integer route2 = o2[0];                 return route1.compareTo(route2);             }         });          int start = routes[0][0];         int end = routes[0][1];         for (int i = 1; i &lt; routes.length; i++){             if (!(start &lt;= routes[i][0] &amp;&amp; routes[i][0] &lt;= end)){                 answer++;                 start = routes[i][0];                 end = routes[i][1];             }else{                 start = Math.max(start, routes[i][0]);                 end = Math.min(end, routes[i][1]);             }         }         return answer;     } }      start와 end범위를 새로 만들어가면서 그 범위안에 들어가지 않으면 anwer++를 해주었다.   이건 한 두세달 전에 짠거라서..아무튼 start를 기준으로 정렬해주었으니 start가 필요있나 싶었다. 그래서 이번에는 start없이 다시 짜보았다.   ver2   import java.util.*; class Solution {     public int solution(int[][] routes) {         int answer = 1;         Arrays.sort(routes, (a,b) -&gt; Integer.compare(a[0], b[0]));          int end = routes[0][1];         for (int i = 0; i &lt; routes.length-1; i++){             end = Math.min(end, routes[i][1]);             if (end &lt; routes[i+1][0]){                 answer++;                 end = routes[i+1][1];             }         }         return answer;     } }           어차피 start로 정렬을 해 주었으니 이전 start보다는 값이 크기 때문에 이전 값에 포함이 될 것이다.            따라서 end만 고려하였다.            end의 값을 현재와 이전 것 중 가장 작은 것으로 저장한다.                       그 이유는, 단속카메라를 중복으로 설치하지 않기 위함이다.                                   예를들어  [-18, 5] [-18, -15] [-15 -10] [-10 -5] [-5 5]가 있으면,               [-18, 5] [-18, -15] 📷 [-15 -10] [-10 -5] [-5 5]               저기에 카메라를 설치하면               [-18, 5] [-18, -15] [-15 -10] 📷 [-10 -5] [-5 5]               여기에 설치하면 중복이 된다.               [-18, 5] [-18, -15]📷 [-15 -10] [-10 -5] 📷 [-5 5] 이게 더 적게 설치하는 방법일 것이다.               만약, 항상 end = routes[i][1]로 한다면, 아마 전자에 설치되고 후자에도 설치가 된다.               즉, 카메라가 볼 수 있는 마지막 영역이라고 생각하면 될 것 같다 . ❗️                                            end보다 다음 것이 클 경우 answer+1을 해주고,                        end를 그 다음 것의 end로 업데이트 해준다. 👉 이것은 카메라가 볼 수 있는 마지막 영역 ‼️                   느낀점   뭔가 더 좋은 코드를 짤 수 있을거 같다. routes[i+1][0] 이런식으로 짜는게 좀 찜찜하다ㅠㅠ 친구들과 이야기 하면서 더 좋은 방법을 생각해서 다시 짜봐야 겠다..   머리속에서 정확히 이해되지않는 문제다..약 70%이해한것 같다….꼭 100퍼센트로 이해하고 싶다.   그리고 sort를 더 간단하게 할 수 있는 것을 발견 하였다. 꼭 기억해서 다음에는 이걸로 풀어볼 것이다.   Arrays.sort(routes, new Comparator&lt;int[]&gt;() {             @Override             public int compare(int[] o1, int[] o2) {                 return o1[0]-o2[0];             }         }); //‼️‼️‼️‼️이거 기억하기‼️‼️‼️‼️‼️‼️ Arrays.sort(routes, (a,b) -&gt; Integer.compare(a[0], b[0]));      문제 : https://programmers.co.kr/learn/courses/30/lessons/42884   저장소1 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/2.PROGRAMMERS/Greedy_단속카메라_ver2.java   저장소2 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/2.PROGRAMMERS/Greedy_단속카메라_ver2.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","Greedy","Programmers"],
        "url": "http://localhost:4000/algorithm/Algorithms-Programmers_%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ14891-톱니바퀴",
        "excerpt":"문제   총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다.      이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다.         톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자.      두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다.      위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다.      톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다.   다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.   출력   총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다.      1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점   2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점   3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점   4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점   예제 입력 1   10101111 01111101 11001110 00000010 2 3 -1 1 1   예제 출력 1   7   예제 입력 2   11111111 11111111 11111111 11111111 3 1 1 2 1 3 1   예제 출력 2   15   예제 입력 3   10001011 10000011 01011011 00111101 5 1 1 2 1 3 1 4 1 1 -1   예제 출력 3   6   예제 입력 4   10010011 01010011 11100011 01010101 8 1 1 2 1 3 1 4 1 1 -1 2 -1 3 -1 4 -1   예제 출력 4   5   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.LinkedList; import java.util.Queue;  public class Main {     static int size = 8;     static int gearCount = 4;     static int[][] map;      public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         map = new int[gearCount][size];         for (int i = 0; i &lt; gearCount; i++) {             String[] input = bufferedReader.readLine().split(\"\");             for (int j = 0; j &lt; size; j++) {                 map[i][j] = Integer.parseInt(input[j]);             }         }          int K = Integer.parseInt(bufferedReader.readLine());         for (int i = 0; i &lt; K; i++) {             String[] input = bufferedReader.readLine().split(\" \");             int curGear = Integer.parseInt(input[0]) - 1;             int dir = Integer.parseInt(input[1]);             int curDir = dir;              Queue&lt;Rotation&gt; queue = new LinkedList&lt;&gt;();             queue.add(new Rotation(curGear, dir));             for (int k = curGear; k &lt; gearCount - 1; k++) {//front                 if (!rotationCheck(k, curDir, true)) {                     curDir = 0 - curDir;                     queue.add(new Rotation(k + 1, curDir));                 }else break;             }              curDir = dir;             for (int j = curGear; j &gt; 0; j--) {                 if (!rotationCheck(j, curDir, false)) {                     curDir = 0 - curDir;                     queue.add(new Rotation(j - 1, curDir));                 }else break;             }              while (!queue.isEmpty()) {                 Rotation curRotation = queue.poll();                 shiftGear(curRotation.gear, curRotation.dir);             }         }         System.out.println(result());     }      public static boolean rotationCheck(int cur, int dir, boolean front) {         if (front) {             if (map[cur][2] != map[cur + 1][6]) return false;         } else {             if (map[cur - 1][2] != map[cur][6]) return false;         }         return true;     }      public static void shiftGear(int cur, int dir) {//dir:1-시계, 0-반시계         if (dir == 1) {//시계             int last = map[cur][size - 1];             for (int i = size - 1; i &gt; 0; i--) {                 map[cur][i] = map[cur][i - 1];             }             map[cur][0] = last;         } else {             int first = map[cur][0];             for (int i = 0; i &lt; size - 1; i++) {                 map[cur][i] = map[cur][i + 1];             }             map[cur][size - 1] = first;         }     }      public static int result() {         int answer = 0;         for (int i = 0; i &lt; gearCount; i++) {             if (map[i][0] == 1) {                 answer += Math.pow(2, i);             }         }         return answer;     } }  class Rotation {     int gear;     int dir;     Rotation(int gear, int dir) {         this.gear = gear;         this.dir = dir;     } }           나는 이 문제를 보자마자 한 톱니가 돌아갈 때 같이 돌아 갈 톱니들을 한번에 돌려야 겠다고 생각을 하였다.            그래서 돌아가는 톱니 앞 뒤로 돌아갈 수 있는 톱니들을 큐에넣었다.       for (int k = curGear; k &lt; gearCount - 1; k++) {//front   if (!rotationCheck(k, curDir, true)) {     curDir = 0 - curDir;     queue.add(new Rotation(k + 1, curDir));   }else break; }    curDir = dir; for (int j = curGear; j &gt; 0; j--) {   if (!rotationCheck(j, curDir, false)) {     curDir = 0 - curDir;     queue.add(new Rotation(j - 1, curDir));   }else break; }                           public static boolean rotationCheck(int cur, int dir, boolean front)           이 함수는 cur의 다음 것이 회전을 하는 가를 판별을 하여 retrun해 준다.           false 일 경우 다음 것을 회전시켜야 하는데, 그 방향은 현재와 다른 방향이기때문에           curDir = 0 - curDir;//현재방향의 반대. 1 -&gt; -1, -1 -&gt; 1 queue.add(new Rotation(k + 1, curDir));                   이렇게 큐에 넣어 주었다.                        그 다음 큐에 있는 것을 하나씩 빼서 한번에 회전을 시켜준다.         while (!queue.isEmpty()) {     Rotation curRotation = queue.poll();     shiftGear(curRotation.gear, curRotation.dir);   }           public static void shiftGear(int cur, int dir)       이 함수는 회전시켜주는 함수이다. dir가 1이면 시계방향으로 –&gt; 이 방향으로 한칸씩 이동한다.       ‼️ 이 부분을 ArrayList를 사용했다면 앞에서 한개 remove하고 뒤에서 add했으면 쉬웠을 거 같기도 하다!!            회전이 완료되면 출력조건에 맞게 결과 값을 출력해준다.       //출력조건 1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점 2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점 3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점 4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점           public static int result() {   int answer = 0;   for (int i = 0; i &lt; gearCount; i++) {     if (map[i][0] == 1) {       answer += Math.pow(2, i);     }   }  return answer; }           느낀점   경사로보다는 쉬웠던거 같다! 뭔가 인덱스 적으로 많이 난해하지 않아서 그냥 생각하는 대로 구현을 했다. 다만 코드가 또 엄청 길어서 다음에는 조금 더 짧게 하는 방법을 고민해봐야겠다. 지금은 큐로 한번에 했지만 검사하는 동시에 회전시킬수는 없나 ? 아무튼 고민해 봐야겠다 ! 그리고 이제 시뮬은 40분정도 시간을 꼭 재면서 풀어야 겠다. 오늘도 풀다가 무한도전 봤다 흑흑      문제: https://www.acmicpc.net/problem/14891   저장소: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/3.SWEA/Q_14891_톱니바퀴.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","삼성코테","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ14891_%ED%86%B1%EB%8B%88%EB%B0%94%ED%80%B4/",
        "teaser":null},{
        "title": "[STUDY]좋은 git커밋 메시지를 작성하기 위한 7가지 약속",
        "excerpt":"https://meetup.toast.com/posts/106 이 포스팅을 읽고, Git에 대해 회고 아닌 회고와 배운 점을 정리하고자 한다.   Git 커밋 메세지를 잘 쓰려고 노력해야 하는 이유      더 좋은 커밋 로그 가독성   더 나은 협업과 리뷰 프로세스   더 쉬운 코드 유지보수   ✔️인턴 시절 협업을 해보면서 커밋메세지의 중요성에 대해 알게 되었다. 처음에는 나도 커밋 메세지를 대충 작성했는데 나중에 필요한 코드를 찾을 경우 커밋메세지를 보고 찾는 경우가 많았다. 그 뒤로 커밋 메세지를 기능단위로 나누면서 해야겠다고 생각했다. 하지만 특정한 형식으로 커밋 메세지를 작성하지는 않았다. 이 포스팅을 보고 많은 것을 배워야 겠다 !   좋은 Git 커밋 메시지를 작성하기 위한 7가지 약속   #1. 제목과 본문을 한 줄 띄워 분리하기   커밋메세지는 50자 이내 요약문자과 빈줄 하나, 그리고 설명문으로 구성하면 좋다.   빈줄 하나를 넣는 이유는 git log –online을 사용했을 때 출력이 보기 좋게 하기 위함이다.   아직 긴 commit메세지를 작성해 본적은 없지만 알아둬야 겠다.! git log / git log --online / git shortlog 알아두기‼️   #2. 제목은 영문 기준 50자 이내로   더 읽기 좋은 커밋 메세지를 만들기위해 노력 하라 !   인턴을 하며 글자수 상관없이 작성했던 것 같다. 물론 한글이었지만. 짧고 간결하게 작성하도록 해야겠다.   #3.제목 첫글자를 대문자로   요즘 가장 지키기 위해 노력하는 부분이다. 하지만 귀찮을 때 그냥 올리기도 하는데 지키도록 해야겠다.  알고리즘 풀면 Solve Q_문제번호_문제이름 이런식으로 작성하도록 해야겠다.   #4. 제목 끝에 . 금지   #5. 제목은 명령조로   가장 중요한 것 이다 !   제목을 작성하거나 한 줄 메시지로 커밋을 할 때, 즉 커밋메세지 가장 첫 문장의 영문법은 명령조로 해야한다. 명령조니까 첫 단어는 동사원형으로 쓰여야 한다.           왜 ⁉️       git은 스스로가 자동 커밋을 작성할 때 명령문을 사용하고 있다. 예를 들어 git merge를 실행했을 때 커밋 메세지 기본 값은 이러하다.       Merge pull request #123 from someuser/somebranch           이처럼 커밋 메시지를 명령문으로 작성하는 것은 git의 빌트-인 컨벤션(Built-in Convention)을 그대로 따른다는 것을 의미한다.            명령문 예!       - Fix - Add - Remove - Use - Refactor - Update - Improve - Make - Implement - Revise - Correct - Ensure - Prevent - Avoid - Move - Rename - Allow - Verify - Set - Pass           #6. 본문은 영어 기준 72자마다 줄 바꾸기   git은 자동으로 커밋 메세지 줄바꿈을 하지 않는다. 단순한 git log명령어 입력만으로도 보기 좋은 메시지를 만들고자 한다면 적당한 위치에서 엔터키를 눌러 바꿔줘야 한다. 그 적당한 위치로 72자를 추천한다.   #7. 본문은 어떻게보다 무엇을, 왜에 맞춰 작성하기   TIP- 커밋 메시지로 Git이슈 자동 종료시키기   git에 커밋 메시지를 특정한 단어를 사용해 자동으로 이슈를 종료시키는 기능이 탑재되어있다. 이 예약어는 커밋 메시지 안의 어느 위치에서나 사용 가능하다. 형식은   키워드 #이슈번호   Git이 이슈 종료로 인식하는 키워드는 다음과 같다.   - Close / Closes / Closed - fix / fixex / fixed - resolve / resolves/ resolved   느낀점   위에서 말한 것들을 모두 지키기는 쉽지 않을 것 같다. 하지만 유의해서 지켜보도록 하겠다 ‼️  ","categories": ["GIT"],
        "tags": ["GIT"],
        "url": "http://localhost:4000/git/Study-Git-Commit%EB%A9%94%EC%84%B8%EC%A7%80%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1012-유기농배추",
        "excerpt":"문제   차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.   (한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)   한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.   예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.   (0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)                  1       1       0       0       0       0       0       0       0       0                       0       1       0       0       0       0       0       0       0       0                 0       0       0       0       1       0       0       0       0       0                 0       0       0       0       1       0       0       0       0       0                 0       0       1       1       0       0       0       1       1       1                 0       0       0       0       1       0       0       1       1       1           입력   입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다.   출력   각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.   예제 입력 1   2 10 8 17 0 0 1 0 1 1 4 2 4 3 4 5 2 4 3 4 7 4 8 4 9 4 7 5 8 5 9 5 7 6 8 6 9 6 10 10 1 5 5   예제 출력 1   5 1   나의 코드   DFS   import java.io.BufferedReader; import java.io.InputStreamReader;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int N, M;     static int[][] map;     static boolean[][] visited;     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         int testCase = Integer.parseInt(bufferedReader.readLine());         while (testCase-- &gt; 0){             String[] input = bufferedReader.readLine().split(\" \");             M = Integer.parseInt(input[0]);             N =Integer.parseInt(input[1]);             int K = Integer.parseInt(input[2]);             map = new int[N][M];             visited = new boolean[N][M];              for (int i = 0; i &lt; K; i++){                 String[] point = bufferedReader.readLine().split(\" \");                 int x = Integer.parseInt(point[0]);                 int y = Integer.parseInt(point[1]);                 map[y][x] = 1;             }              int answer = 0;             for (int i = 0; i &lt; N; i++){                 for (int j = 0; j &lt; M; j++){                     if (map[i][j] == 1 &amp;&amp; !visited[i][j]){                         answer++;                         DFS(j, i);                     }                 }             }             System.out.println(answer);         }     }      public static void DFS(int x, int y){         visited[y][x] = true;          for (int i = 0; i &lt; 4; i++){             int nextX = x + dx[i];             int nextY = y + dy[i];              if (nextX &lt; 0 || nextY &lt; 0 || M &lt;= nextX || N &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == 0) continue;             DFS(nextX, nextY);         }     } }      떨어져 있는 영역을 구하는 문제로 DFS랑 BFS다 구현할 수 있는 문제다. 나는 DFS가 구현이 더 간단해서 DFS로 먼저 풀어보았다.   그냥 1인 영역을 찾아서 그 1인 영역 전체를 visited를 true로 만드는 식이다. 이때 DFS는 깊이우선으로 보는 것이고, BFS는 넓이 우선으로 보는 것이고. 나는 이런 문제에서 DFS가 구현이 간단해서 더 좋다.   BFS   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.LinkedList; import java.util.Queue;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int N, M;     static int[][] map;     static boolean[][] visited;     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         int testCase = Integer.parseInt(bufferedReader.readLine());         while (testCase-- &gt; 0){             String[] input = bufferedReader.readLine().split(\" \");             M = Integer.parseInt(input[0]);             N =Integer.parseInt(input[1]);             int K = Integer.parseInt(input[2]);             map = new int[N][M];             visited = new boolean[N][M];              for (int i = 0; i &lt; K; i++){                 String[] point = bufferedReader.readLine().split(\" \");                 int x = Integer.parseInt(point[0]);                 int y = Integer.parseInt(point[1]);                 map[y][x] = 1;             }              int answer = 0;             for (int i = 0; i &lt; N; i++){                 for (int j = 0; j &lt; M; j++){                     if (map[i][j] == 1 &amp;&amp; !visited[i][j]){                         answer++;                         BFS(j, i);                     }                 }             }             System.out.println(answer);         }     }      public static void BFS(int x, int y){         Queue&lt;Point&gt; queue = new LinkedList&lt;&gt;();         queue.add(new Point(x, y));         visited[y][x] = true;          while (!queue.isEmpty()){             Point curPoint = queue.poll();             for (int i = 0; i &lt; 4; i++){                 int nextX = curPoint.x + dx[i];                 int nextY = curPoint.y + dy[i];                  if (nextX &lt; 0 || nextY &lt; 0 || M &lt;= nextX || N &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == 0) continue;                 queue.add(new Point(nextX, nextY));                 visited[nextY][nextX] = true;             }         }     } }  class Point{     int x;     int y;     Point(int x, int y){         this.x = x;         this.y = y;     } }      DFS로만 풀어봤는데 BFS로 그냥 한번 풀어봤다.            1인 영역을 큐에 다 넣고 했어도 될거 같고 내방법으로 했어도 될거 같다.           느낀점   DFS/BFS는 조금만 응용되어도 어려워서 기본을 완전히 이해하는게 중요한거 같다. 어려운 문제도 쉽게 풀고 싶다 !      문제: https://www.acmicpc.net/problem/1012   저장소:            DFS: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1012_유기농배추_0114_DFS.java       BFS: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1012_유기농배추_0114_BFS.java          ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS/BFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1012_%EC%9C%A0%EA%B8%B0%EB%86%8D%EB%B0%B0%EC%B6%94/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ2178-미로탐색",
        "excerpt":"문제   N×M크기의 배열로 표현되는 미로가 있다.                  1       0       1       1       1       1                       1       0       1       0       1       0                 1       0       1       0       1       1                 1       1       1       0       1       1           미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.   위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.   입력   첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.   출력   첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.   예제 입력 1   4 6 101111 101010 101011 111011   예제 출력 1   15   예제 입력 2   4 6 110110 110110 111111 111101   예제 출력 2   9   예제 입력 3   2 25 1011101110111011101110111 1110111011101110111011101   예제 출력 3   38   예제 입력 4   7 7 1011111 1110001 1000001 1000001 1000001 1000001 1111111   예제 출력 4   13   나의 코드   BFS   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.LinkedList; import java.util.Queue;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int N, M;// 세로, 가로     static int[][] map;     static boolean[][] visited;      public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] inputNM = bufferedReader.readLine().split(\" \");         N = Integer.parseInt(inputNM[0]);         M = Integer.parseInt(inputNM[1]);         map = new int[N][M];         visited = new boolean[N][M];          for (int i = 0; i &lt; N; i++) {             String[] input = bufferedReader.readLine().split(\"\");             for (int j = 0; j &lt; M; j++) {                 map[i][j] = Integer.parseInt(input[j]);             }         }         BFS(0, 0);         System.out.println(map[N-1][M-1]);     }      public static void BFS(int x, int y) {         Queue&lt;com.company.Point&gt; queue = new LinkedList&lt;&gt;();         queue.add(new com.company.Point(x, y));         visited[y][x] = true;          while (!queue.isEmpty()){             com.company.Point curPoint = queue.poll();             if (curPoint.x == M-1 &amp;&amp; curPoint.y == N-1) return;              for (int i = 0; i &lt; 4; i++){                 int nextX = curPoint.x + dx[i];                 int nextY = curPoint.y + dy[i];                  if (nextX &lt; 0 || nextY &lt; 0 || M &lt;= nextX || N &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == 0) continue;                 visited[nextY][nextX] = true;                 map[nextY][nextX] += map[curPoint.y][curPoint.x];                 queue.add(new com.company.Point(nextX, nextY));             }         }     } } class Point{     int x;     int y;     Point(int x, int y){         this.x = x;         this.y = y;     } }   DFS- 시간초과   import java.io.BufferedReader; import java.io.InputStreamReader;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int N, M;// 세로, 가로     static int[][] map;     static boolean[][] visited;     static int min = Integer.MAX_VALUE;      public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] inputNM = bufferedReader.readLine().split(\" \");         N = Integer.parseInt(inputNM[0]);         M = Integer.parseInt(inputNM[1]);          map = new int[N][M];         visited = new boolean[N][M];          for (int i = 0; i &lt; N; i++) {             String[] input = bufferedReader.readLine().split(\"\");             for (int j = 0; j &lt; M; j++) {                 map[i][j] = Integer.parseInt(input[j]);             }         }          DFS(0, 0, 0);         System.out.println(min);     }      public static void DFS(int x, int y, int count) {         visited[y][x] = true;         count++;          if (x == M - 1 &amp;&amp; y == N - 1) {             min = Math.min(min, count);             return;         }          for (int i = 0; i &lt; 4; i++) {             int nextX = x + dx[i];             int nextY = y + dy[i];              if (nextX &lt; 0 || nextY &lt; 0 || M &lt;= nextX || N &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == 0 || min &lt; count)                 continue;             visited[nextY][nextX] = true;             DFS(nextX, nextY, count);             visited[nextY][nextX] = false;         }     } }           BFS는 너비우선 탐색으로 범위를 넓혀가면서 탐색을 한다. 그렇기 때문에 목적지 닿는 곳을 최소로 찾을수 있을 것이다. 그리고 찾으면 종료된다.            하지만 DFS는 깊이우선 탐색으로 한가지 경로를 잡으면 끝까지 가고, 그 다음 경로로 끝가지 가고 이런식이다. 그렇기 때문에 최소값을 찾기 위해서 모든 경로를 다 본 다음에 최소값을 찾아내야 한다.            ‼️ 따라서 최단 경로에는 BFS가 더 적합하다 ‼️              위 DFS경우 조건을 걸어서 최단 거리 없을거 같은 경우를 제외시켜주는 ? 그런걸 나중에 고민해서 더 짜봐야겠다.                BFS일 경우 탐색 길을 누적하는 것으로 하였다. 그러면 목적지에 최단경로의 값이 들어가 있을 것이다.       //입력1 101111 101010 101011 111011    //출력1 1 0 9 10 11 12 2 0 8 0  12 0 3 0 7 0  13 14 4 5 6 0  14 15    //입력2 110110 110110 111111 111101    //출력2 1 2 0 8 9 0 2 3 0 7 8 0 3 4 5 6 7 8 4 5 6 7 0 9           보기 어렵지만 아무튼 이런식으로 !       느낀점   BFS에 비해 DFS는 구현하기 더 간단하지만 시간초과 문제를 고려해야한다. 쓸모없는 탐색이 많을 수록 시간초과가 잘 된다. 그런 점에서 이 문제는 BFS가 더 적절했던거 같다. 문제를 보고 먼저 BFS/DFS중 어떤게 더 적합한 방법인지 고민하고 코드를 짜도록 해야겠다.  🧐이 문제를 통해 최단거리에는 BFS가 더 적합하다는 것을 알게되었다. 🧐      문제: https://www.acmicpc.net/problem/2178   저장소:            DFS: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2178_미로탐색_0114_DFS.java       BFS: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2178_미로탐색_0114_BFS.java          ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS/BFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ2178_%EB%AF%B8%EB%A1%9C%ED%83%90%EC%83%89/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ2667-단지번호붙이기",
        "excerpt":"문제   &lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.      입력   첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.   출력   첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.   예제 입력 1   7 0110100 0110101 1110101 0000111 0100000 0111110 0111000   예제 출력 1   3 7 8 9   나의 코드   DFS   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int size;     static int[][] map;     static boolean[][] visited;     static int count;     public static void main(String[] args) throws Exception{         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         size = Integer.parseInt(bufferedReader.readLine());         map = new int[size][size];         visited = new boolean[size][size];          for (int i = 0; i &lt; size; i++){             String[] input = bufferedReader.readLine().split(\"\");             for (int j = 0; j &lt;size; j++){                 map[i][j] = Integer.parseInt(input[j]);             }         }          int aptSet = 0;         ArrayList&lt;Integer&gt; aptCount = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; size; i++){             for (int j = 0; j &lt;size; j++){                 if (map[i][j] != 0 &amp;&amp; !visited[i][j]){                     aptSet++;                     count = 0;                     DFS(j, i);                     aptCount.add(count);                 }             }         }         System.out.println(aptSet);         Collections.sort(aptCount);         for (int a : aptCount){             System.out.println(a);         }     }      public static void DFS(int x, int y){         count++;         visited[y][x] = true;         for (int i =0; i &lt; 4; i++){             int nextX = x + dx[i];             int nextY = y + dy[i];              if (nextX &lt; 0 || size &lt;= nextX || nextY &lt; 0 || size &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == 0) continue;             DFS(nextX, nextY);         }     } }   BFS   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections; import java.util.LinkedList; import java.util.Queue;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int size;     static int[][] map;     static boolean[][] visited;     static int count;     public static void main(String[] args) throws Exception{         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         size = Integer.parseInt(bufferedReader.readLine());         map = new int[size][size];         visited = new boolean[size][size];          for (int i = 0; i &lt; size; i++){             String[] input = bufferedReader.readLine().split(\"\");             for (int j = 0; j &lt;size; j++){                 map[i][j] = Integer.parseInt(input[j]);             }         }          int aptSet = 0;         ArrayList&lt;Integer&gt; aptCount = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; size; i++){             for (int j = 0; j &lt; size; j++){                 if (map[i][j] != 0 &amp;&amp; !visited[i][j]) {                     aptSet++;                     BFS(j, i);                     aptCount.add(count);                 }             }         }         System.out.println(aptSet);         Collections.sort(aptCount);         for (int a : aptCount){             System.out.println(a);         }     }      public static void BFS(int x, int y){         Queue&lt;Point&gt; queue = new LinkedList&lt;&gt;();         queue.add(new Point(x, y));         visited[y][x] = true;         count = 0;         while (!queue.isEmpty()){             Point cur = queue.poll();             count++;             for (int i = 0; i &lt; 4; i++){                 int nextX = cur.x + dx[i];                 int nextY = cur.y + dy[i];                  if (nextX &lt; 0 || nextY &lt; 0 || size &lt;= nextX || size &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == 0) continue;                 queue.add(new Point(nextX, nextY));                 visited[nextY][nextX] = true;             }         }     } } class Point{     int x;     int y;     Point(int x, int y){         this.x = x;         this.y = y;     } }   느낀점   BFS/ DFS의 가장 기본적인 문제라고 생각한다 ‼️ 개념을 잡고 싶으면 이문제를 다시 풀어봐야 겠다.그리고 뭔가 예전에는 BFS가 더 쉽다고 생각했지만 지금은 DFS가 구현이 더 간단해서 좋은거 같다. BFS하려면 x,y 좌료를 저장하는 큐를 만들어야 하고… 하지만 재귀라는 것은 알다가도 갑자기 이해 안되는 순간이 있기 때문에.. 상황에 맞는 풀이법으로 접근하도록 해야겠다 🧐      문제: https://www.acmicpc.net/problem/2667   저장소:            DFS: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2667_단지번호붙이기_0114_DFS.java       BFS: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2667_단지번호붙이기_0114_BFS.java          ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS/BFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ2667_%EB%8B%A8%EC%A7%80%EB%B2%88%ED%98%B8%EB%B6%99%EC%9D%B4%EA%B8%B0/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ7576-토마토",
        "excerpt":"문제   철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.      창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.   토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.   입력   첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.   출력   여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.   예제 입력 1   6 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1   예제 출력 1   8   예제 입력 2   6 4 0 -1 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1   예제 출력 2   -1   예제 입력 3   6 4 1 -1 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 -1 0 0 0 0 0 -1 1   예제 출력 3   6   예제 입력 4   5 5 -1 1 0 0 0 0 -1 -1 -1 0 0 -1 -1 -1 0 0 -1 -1 -1 0 0 0 0 0 0   예제 출력 4   14   예제 입력 5   2 2 1 -1 -1 1   예제 출력 5   0   나의 코드-BFS   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.LinkedList; import java.util.Queue;  public class Main {     static int[] dx = {-1, 1, 0, 0};     static int[] dy = {0, 0, -1, 1};     static int N; //세로     static int M; //가로     static int[][] map;     static boolean[][] visited;      public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] MN = bufferedReader.readLine().split(\" \");         M = Integer.parseInt(MN[0]);         N = Integer.parseInt(MN[1]);         map = new int[N][M];         visited = new boolean[N][M];         Queue&lt;com.company.Point&gt; queue = new LinkedList&lt;&gt;();          for (int i = 0; i &lt; N; i++) {             String[] input = bufferedReader.readLine().split(\" \");             for (int j = 0; j &lt; M; j++) {                 map[i][j] = Integer.parseInt(input[j]);                 if (map[i][j] == 1) {                     queue.add(new com.company.Point(j, i));                 }             }         }         BFS(queue);         System.out.println(checkMap());     }      public static void BFS(Queue&lt;com.company.Point&gt; queue) {         while (!queue.isEmpty()) {             com.company.Point curPoint = queue.poll();             visited[curPoint.y][curPoint.x] = true;             for (int i = 0; i &lt; 4; i++) {                 int nextX = curPoint.x + dx[i];                 int nextY = curPoint.y + dy[i];                  if (nextX &lt; 0 || nextY &lt; 0 || M &lt;= nextX || N &lt;= nextY || visited[nextY][nextX] || map[nextY][nextX] == -1 || map[nextY][nextX] == 1)                     continue;                 visited[nextY][nextX] = true;                 map[nextY][nextX] += map[curPoint.y][curPoint.x] + 1;                 queue.add(new com.company.Point(nextX, nextY));             }         }     }      public static int checkMap() {         int max = Integer.MIN_VALUE;         for (int i = 0; i &lt; N; i++) {             for (int j = 0; j &lt; M; j++) {                 if (map[i][j] == 0) return -1;                 if (map[i][j] != -1) max = Math.max(max, map[i][j]);             }         }         return max - 1;     } }  class Point {     int x;     int y;      Point(int x, int y) {         this.x = x;         this.y = y;     } }        이 문제는 시작점이 1개가 아니라 여러곳일 수도 있다는 것이 핵심인거 같다.   일단 시작점이 될 수 있는 것을 모두 큐에 담고, 그것들을 하나씩 넓혀 가는 것이다.            이게는 큐가 완벽하게 적합하다.       시작점이 A와 B가 있어 큐에 AB가있는데 A로부터 퍼진 것들이 B뒤로 오기 때문에 퍼짐을 동시에 할수 있게 되는 것이다 ! (말이 좀 어렵나? 아무튼.)           느낀점   재밌당      문제: https://www.acmicpc.net/problem/7576   저장소: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_7576_토마토_0114_BFS.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS/BFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ7576_%ED%86%A0%EB%A7%88%ED%86%A0/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1698-숨바꼭질",
        "excerpt":"문제   수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.   수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.   입력   첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.   출력   수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.   예제 입력 1   5 17   예제 출력 1   4   힌트   수빈이가 5-10-9-18-17 순으로 가면 4초만에 동생을 찾을 수 있다.   나의 코드-BFS   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.LinkedList; import java.util.Queue;  public class Main {     static int MAX = 100000;     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] input = bufferedReader.readLine().split(\" \");         int N = Integer.parseInt(input[0]);//수빈위치         int K = Integer.parseInt(input[1]);//동생위치         Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         queue.add(N);         int[] map = new int[MAX + 1];         while (!queue.isEmpty()) {             int temp = queue.poll();             if (temp == K){                 System.out.print(map[temp]);                 return;             }             int[] next = new int[3];             next[0] = temp - 1;             next[1] = temp + 1;             next[2] = temp * 2;              for (int i = 0; i &lt; 3; i++) {                 if (next[i] &lt; 0 || next[i] &gt; MAX || map[next[i]] != 0) {                     continue;                 }                 map[next[i]] = map[temp] + 1;                 queue.add(next[i]);             }         }     } }           이 문제는 최소한으로 목적지를 구하는 문제로, 따라서 BFS로 접근해서 풀었다.            각 정점을 보고 각 정점마다 x-1, x+1, x*2를 해준다는 점에서 아주 BFS적이다.            처음에는 map에 값을 누적하지 않고, class를 만들어 위치(position)와 움직인 횟수(count)를 해주었다.                       이렇게 하면 방문했던 곳을 또 방문할 수 있다.(많이 반복할수록 최소로 방문하는 것에서 멀어진다.) -&gt;visited 배열을 또 사용해야함.                        따라서 map에 누적을 해주고,           if (next[i] &lt; 0 || next[i] &gt; MAX || map[next[i]] != 0) {   continue; } //map[next[i]] != 0 라는 조건을 추가해주었다.                           느낀점   DFS로 접근했다가 다시 다 지우고 다시 풀었다…앞으로 문제를 잘 읽고 생각‼️ 부터 하고 풀어야겠다.           문제 : https://www.acmicpc.net/problem/1697     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_1697_숨바꼭질_0116.java     ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS/BFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1698_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ14503-로봇청소기",
        "excerpt":"문제   로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.   로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.   로봇 청소기는 다음과 같이 작동한다.      현재 위치를 청소한다.   현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.            왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.       왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.       네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.       네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.           로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.   입력   첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)   둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.   셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 장소의 모든 외곽은 벽이다.   로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.   출력   로봇 청소기가 청소하는 칸의 개수를 출력한다.   예제 입력 1   3 3 1 1 0 1 1 1 1 0 1 1 1 1   예제 출력 1   1   예제 입력 2   11 10 7 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 1 1 0 1 1 0 0 1 1 0 0 0 0 1 1 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1   예제 출력 2   57   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader;  public class Main {     static int[] dx = {0, 1, 0, -1};     static int[] dy = {-1, 0, 1, 0};     static int N, M;     static int[][] map;     static int count = 1;      public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String[] NM = bufferedReader.readLine().split(\" \");         N = Integer.parseInt(NM[0]);//세로         M = Integer.parseInt(NM[1]);//가로          String[] input = bufferedReader.readLine().split(\" \");         int startY = Integer.parseInt(input[0]);         int startX = Integer.parseInt(input[1]);         int d = Integer.parseInt(input[2]);         map = new int[N][M];          for (int i = 0; i &lt; N; i++) {             String[] tmp = bufferedReader.readLine().split(\" \");             for (int j = 0; j &lt; M; j++) {                 map[i][j] = Integer.parseInt(tmp[j]);             }         }         DFS(startX, startY, d);         System.out.println(count);     }      static void DFS(int x, int y, int dir) {         map[y][x] = 5;          for (int i = 0; i &lt; 4; i++) {             dir = (dir + 3) % 4;             int nextX = x + dx[dir];             int nextY = y + dy[dir];              if (nextX &lt; 0 || nextY &lt; 0 || nextX &gt;= M || nextY &gt;= N || map[nextY][nextX] != 0) continue;             count++;             DFS(nextX, nextY, dir);             return;         }          int backDir = (dir + 2) % 4;         int backX = x + dx[backDir];         int backY = y + dy[backDir];          if (backX &gt;= 0 &amp;&amp; backY &gt;= 0 &amp;&amp; backX &lt; M &amp;&amp; backY &lt; N &amp;&amp; map[backY][backX] != 1) {             DFS(backX, backY, dir);         }     } }            최대한 문제 가이드대로 풀어주면 쉽다.            로봇 청소기의 작동 방법은                       현재 위치를 청소한다.         현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.                        왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.             왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.             네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.             네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.                                           이를 코드로 작성하면       static void DFS(int x, int y, int dir) {         map[y][x] = 5;//1. 현재 위치를 청소한다.            for (int i = 0; i &lt; 4; i++) {//2. 현재위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.             dir = (dir + 3) % 4;             int nextX = x + dx[dir];             int nextY = y + dy[dir];                if (nextX &lt; 0 || nextY &lt; 0 || nextX &gt;= M || nextY &gt;= N || map[nextY][nextX] != 0) continue;//b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.             count++; //a.왼쪽 방향에서 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸 전진하고 1번부터 진행한다.             DFS(nextX, nextY, dir);             return;//여기서 return안하면 한 다른경로가 시작되기 때문에 여기서 끝 ‼️         }            int backDir = (dir + 2) % 4;         int backX = x + dx[backDir];         int backY = y + dy[backDir];   \t\t\t//c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.   \t\t\t//d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.         if (backX &gt;= 0 &amp;&amp; backY &gt;= 0 &amp;&amp; backX &lt; M &amp;&amp; backY &lt; N &amp;&amp; map[backY][backX] != 1) {             DFS(backX, backY, dir);         }     }                여기서 방향을 계산하는게 처음에는 헷갈렸어서 동, 서, 남, 북 일때 방향을 dx, dy를 다 주었었다. 하지만 그러니까 저 배열이 엄청 길어졌고 값이 0~4사이이기 때문에 계산을 해보았다.              먼저, 북쪽(0) / 동쪽(1) / 남쪽(2) / 서쪽(3) 으로 설정이 되어있다.         북쪽의 경우 왼쪽부터 보면, 서-&gt;남-&gt;동-&gt;북, 3-&gt;2-&gt;1-&gt;0이 된다.         다음 값은 자기보다 1씩 작은 값이 되는데 그 범위가 0-3안이다. 그렇기 때문에 자기보다 한 값작은 것을 하려면 +3을 한다음 %4를 하면 된다.         (+4를 하면 자기 자신이 될 것이고, +2하면 자기보다 2작은 값이 될 것이다. )         dir = (dir + 3) % 4; //이런식으로 회전할 때 방향을 지정해 주었다.                       뒤를 보는 방향도 위의 방법과 마찬가지로,       int backDir = (dir + 2) % 4;           이런식으로 해주었다.            전체를 DFS탐색을 하는 상황이 발생했다. 이는 return을 해주지 않아서 그랬다는 것을 알게 되었다.       로봇청소기는 한 경로만으로만 간다. 반면 일반적인 전체탐색 DFS는 한 경로가 끝이 나면 그 경로의 시작점?에서 다른 갈래가 시작되기 때문에 return을 해주었다.       느낀점   진짜 이 문제는 문제대로만 풀면 답이 나오는 문제였다.ㅋㅋ나는 이런 문제를 한 세번 정도 갈아엎고 풀었다… 풀수 있을 것 같으면서 계속 답이 안나오고,,,! 그래서 오래 걸린것 같다ㅠㅠ 근데 막상 풀고나니 진짜 간단한 문제였던..이 문제는 한 다섯번정도 풀어봐야겠다 ! 이 문제는 카카오 괄호? 문제랑 비슷한거 같다. 오랜만에그것도 다시 풀어봐야겠다 !      문제: https://www.acmicpc.net/problem/14503   저장소: https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/3.SWEA/Q_14503_로봇청소기.java  ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","삼성코테","BOJ"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ14503_%EB%A1%9C%EB%B4%87%EC%B2%AD%EC%86%8C%EA%B8%B0/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ11403-경로찾기",
        "excerpt":"문제   가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 정점의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄부터 N개 줄에는 그래프의 인접 행렬이 주어진다. i번째 줄의 j번째 숫자가 1인 경우에는 i에서 j로 가는 간선이 존재한다는 뜻이고, 0인 경우는 없다는 뜻이다. i번째 줄의 i번째 숫자는 항상 0이다.   출력   총 N개의 줄에 걸쳐서 문제의 정답을 인접행렬 형식으로 출력한다. 정점 i에서 j로 가는 경로가 있으면 i번째 줄의 j번째 숫자를 1로, 없으면 0으로 출력해야 한다.   예제 입력 1   3 0 1 0 0 0 1 1 0 0   예제 출력 1   1 1 1 1 1 1 1 1 1   예제 입력 2   7 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0   예제 출력 2   1 0 1 1 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 1 1 1 1 0 0 1 0 0 0 1 0 0 1 0 0 0 0   나의 코드-DFS   import java.io.InputStreamReader; import java.util.Scanner;  public class Main {     static int size;     static int[][] map;     static boolean[][] visited;      public static void main(String[] args){         Scanner scanner = new Scanner(new InputStreamReader(System.in));         size = scanner.nextInt();         map = new int[size][size];         visited = new boolean[size][size];          for (int i = 0; i &lt; size; i++){             for (int j = 0; j &lt; size; j++){                 map[i][j] = scanner.nextInt();             }         }          for (int i = 0; i &lt; size; i++){             for (int j = 0; j &lt; size; j++){                 if (map[i][j] == 1 &amp;&amp; !visited[i][j]){                     DFS(i, j);                 }             }         }         Print(map);     }      public static void DFS(int top, int point){         visited[top][point] = true;         for (int i = 0; i &lt; size; i++){             if (map[point][i] == 1 &amp;&amp; !visited[top][i]){                 map[top][i] = 1;                 DFS(top, i);             }         }      }      public static void Print(int[][] map){         for (int i = 0; i &lt; size; i++){             for (int j = 0; j &lt; size; j++){                 System.out.print(map[i][j] + \" \");             }             System.out.println();         }     } }           나는 이 문제를 한개의 연결 요소에 연결 될 수 있는 것들을 표시하면서 내려갔다.            예를들어       0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0           일때, 0과 연결된 요소들을 표시하였다.       0과 연결된 요소는 0 -&gt; 3이고, 3에서 4, 5 , 그리고 4에서 , 5에서 …. 이런식으로되어 간다. 이것을 DFS로 접근하였다.            일단 시작점이 될 수 있는 것을 모두 큐에 담고, 그것들을 하나씩 넓혀 가는 것이다.             이게는 큐가 완벽하게 적합하다.       시작점이 A와 B가 있어 큐에 AB가있는데 A로부터 퍼진 것들이 B뒤로 오기 때문에 퍼짐을 동시에 할수 있게 되는 것이다 ! (말이 좀 어렵나? 아무튼.)              문제 : https://www.acmicpc.net/problem/11403     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_11403_경로찾기_0119.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS/BFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ11403_%EA%B2%BD%EB%A1%9C%EC%B0%BE%EA%B8%B0/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ10799-쇠막대기",
        "excerpt":"문제   여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.      쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.   각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.   레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.   아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.      이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.      레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.   쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다.   위 예의 괄호 표현은 그림 위에 주어져 있다.   쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다.   쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.   입력   한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다.   출력   잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.   예제 입력 1   ()(((()())(())()))(())   예제 출력 1   17   예제 입력 2   (((()(()()))(())()))(()())   예제 출력 2   24   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Stack;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String input = bufferedReader.readLine();         Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();         int answer = 0;          for (int i = 0; i &lt; input.length(); i++) {             char cur = input.charAt(i);             switch (cur) {                 case '(':                     stack.push(-1);                     break;                 case ')':                     if (stack.peek() == -1) {//'('                         stack.pop();                         stack.push(1);                     } else {                         int tmp = 0;                         while (stack.peek() != -1) {                             tmp += stack.pop();                         }                         stack.pop();                         answer += tmp + 1;                         stack.push(tmp);                     }                     break;             }         }         System.out.println(answer);     } }           () 👈 이거 한개가 레이저다.              레이저가 2개 있다면 1개의 막대기는 2개로 잘린다.       레이저가 2개 있다면 1개의 막대기는 3개로 잘린다.       즉, 한 막대기가 잘리는 갯수는 레이저 갯수 + 1 이다.                ( 인경우에는 스택에 넣었다. 👉 Stack 로 했으므로, **(** 대신 -1을 넣어 주었다.            )인 경우에는 앞에 바로 ( 이 있을 때는 레이저로 레이저 1를 스택에 넣었다.                       만약 앞에 숫자가 있을 때는, 이 막대기가 레이저로 잘려야 할 시간이다.                        레이저들을 다 pop해서 레이저 갯수 + 1을 answer에 저장해 준다.                        그리고 이 레이저 값들은 다시 스택에 넣어준다.                        이에해당하는 코드는                        int tmp = 0; while (stack.peek() != -1) {   tmp += stack.pop(); // ( 👈이게 아닐때까지 값을 꺼내서 tmp에 합한다. 즉 이는 레이저의 갯수가 된다. } stack.pop();//마지막 ( 까지 빼준다. answer += tmp + 1; // 결과에 레이저 갯수 + 1을 해준다. stack.push(tmp); //이 레이저들을 다시 스택에 넣어준다.                           느낀점   프로그래머스에서 풀었던 것인데 뭔가 다시 새롭게 풀었다. 풀고 보니까 코드가 아예 똑같아서 신기했닼ㅋㅋㅋ아무튼 오랜만에 블로그 쓸수 있어서 기분이 좋다~      문제 : https://www.acmicpc.net/problem/10799     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_10799_쇠막대기.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","STACK"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ10799_%EC%87%A0%EB%A7%89%EB%8C%80%EA%B8%B0/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1918-후위표기식",
        "excerpt":"문제   수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 후위 표기법으로는 ab+가 된다.   이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 a+bc를 후위 표기식으로 바꾸면 abc+가 된다.   중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.   예를 들어 a+bc는 (a+(bc))의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 를 괄호 밖으로 꺼내게 되면 (a+bc)가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.   다른 예를 들어 그림으로 표현하면 A+B*C-D/E를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.      이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오   입력   첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 A~Z의 문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 -A+B와 같이 -가 가장 앞에 오거나 AB와 같이 *가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 +, -, *, /, (, )로만 이루어져 있으며, 길이는 100을 넘지 않는다.   출력   첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오   예제 입력 1   A*(B+C)   예제 출력 1   ABC+*   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Stack;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         String input = bufferedReader.readLine();         Stack&lt;Character&gt; stack = new Stack&lt;&gt;();          for (int i = 0; i &lt; input.length(); i++) {             char cur = input.charAt(i);             if ('A' &lt;= cur &amp;&amp; cur &lt;= 'Z') {                 System.out.print(cur);             } else {                 if (cur == '(') {                     stack.push(cur);                 } else if (cur == ')') {                     while (stack.peek() != '(') {                         System.out.print(stack.pop());                     }                     stack.pop();                 } else {//operator                     while (!stack.isEmpty() &amp;&amp; priorityOP(cur) &lt;= priorityOP(stack.peek())) {                         System.out.print(stack.pop());                     }                     stack.push(cur);                 }             }         }          while (!stack.isEmpty()) {             System.out.print(stack.pop());         }     }      public static int priorityOP(Character op) {         if (op == '(' || op == ')') return 0;         else if (op == '+' || op == '-') return 1;         else return 2;     } }   👉후위표기👈식이란 ?           연산자가 피연산자 뒤에 위치하는 후위 표기법이다.                이 것의 장점은 괄호가 필요없다는 점!                 중위표기식을 후위표기식으로 바꾸는 방법은                주어진 중요 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.                  중위표기식 👉 후위표기식   - 준비물 : Stack - 입력이 피연산자이면 출력해준다. - 입력이 연산자일 경우 \t- ( : 스택에 넣어준다. \t- ) : ( 이 나올때까지 모든 연산자를 출력해준다. \t- + - / * : 스택에 넣어준다. \t\t이때, 연산자 우선순위가 중요하다. \t\t연산자 우선순위는 * / &gt; + - 이다. \t\t즉, 연산자 우선 순위가 높으면 먼저 계산이 되어야 하는것이고,  \t\t즉, 이것은 우선 순위가 높을 수록 스택에 오래 머물면 안된다 !!! ‼️   위의 순서로 코드를 짜주었다.           스택 연산            if ('A' &lt;= cur &amp;&amp; cur &lt;= 'Z') {// 피연산자인 경우 출력   System.out.print(cur); } else {   if (cur == '(') { // ( 연산자는 그냥 push     stack.push(cur);   } else if (cur == ')') { // ) 이 나올때까지 모든 연산자 출력     while (stack.peek() != '(') {       System.out.print(stack.pop());     }     stack.pop();   } else {// + - * / 인 경우,      //만약에 스택에 **/가 있고 현재 것이 + 이면 **/다 출력 되어야 함.     while (!stack.isEmpty() &amp;&amp; priorityOP(cur) &lt;= priorityOP(stack.peek())) {       System.out.print(stack.pop());     }     stack.push(cur);//현재꺼를 넣어준다.   } }                우선순위       public static int priorityOP(Character op) {   if (op == '(' || op == ')') return 0;   else if (op == '+' || op == '-') return 1;   else return 2; }           느낀점   내가 생각하기에 스택 을 사용하는 문제중에 가장 기본적이고, 중요하면서도 난이도 있는 문제 같다. 그리고 자료 구조 수업을 들으면서 과제로 중위연산을 후위연산으로 바꾸는 것을 했었었다 ! 해결 방법은 어렵지 않지만 후위표기식을 매번 볼때마다 정확하게 기억에 안나기 때문이다. 이 문제는 꼭 기억해야겠다.~      문제 : https://www.acmicpc.net/problem/1918     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/ab8a525e0eb79ecfc298ab8feb5821e4112685d5/Algorithm/1.BOJ/Q_1918_후위표기식.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","STACK"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1918_%ED%9B%84%EC%9C%84%ED%91%9C%EA%B8%B0%EC%8B%9D/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ1966-프린터큐",
        "excerpt":"문제   여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.      현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.   나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.   예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.   여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.   입력   첫 줄에 test case의 수가 주어진다. 각 test case에 대해서 문서의 수 N(100이하)와 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue의 어떤 위치에 있는지를 알려주는 M(0이상 N미만)이 주어진다. 다음줄에 N개 문서의 중요도가 주어지는데, 중요도는 1 이상 9 이하이다. 중요도가 같은 문서가 여러 개 있을 수도 있다. 위의 예는 N=4, M=0(A문서가 궁금하다면), 중요도는 2 1 4 3이 된다.   출력   각 test case에 대해 문서가 몇 번째로 인쇄되는지 출력한다.   예제 입력 1   3 1 0 5 4 2 1 2 3 4 6 0 1 1 9 1 1 1   예제 출력 1   1 2 5   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Arrays; import java.util.LinkedList;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         int testCase = Integer.parseInt(bufferedReader.readLine());          while (testCase-- &gt; 0) {             String[] NM = bufferedReader.readLine().split(\" \");             int N = Integer.parseInt(NM[0]); //문서수             int M = Integer.parseInt(NM[1]); //문서 결과 찾아야 하는              LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();             int[] priority = new int[N];             String[] input = bufferedReader.readLine().split(\" \");              for (int i = 0; i &lt; N; i++) {                 list.offer(Integer.parseInt(input[i]));                 priority[i] = Integer.parseInt(input[i]);             }             Arrays.sort(priority);             int cur = N - 1;             int answer = 0;              while (!list.isEmpty()) {                 int temp = list.poll();                 if (temp != priority[cur]) {                     list.offer(temp);                     M = (M == 0) ? list.size() - 1 : --M;                 } else {                     cur--;                     answer++;                     if (M == 0) {                         System.out.println(answer);                         break;                     } else {                         M--;                     }                 }             }         }     } }           푸는 방법은 여러가지 있겠지만 내가 푼 방법은       - 큐: 우선순위가 들어가 있음. - priority List: 우선순위가 정렬되어 있으며, 큐에서 우선순위가 높은게 빠질 때 다음 우선순위를 본다. - 찾아야 하는 문서 번호가 M이라고 하면, 이것이 0일때 이 문서가 출력 되는것이다. 따라서 이 값을 -- ++ 하면서 위치를 조정해준다.                프린터큐 작동 방법       Arrays.sort(priority);//우선순위를 정렬해준다.    while (!list.isEmpty()) {   int temp = list.poll();   if (temp != priority[cur]) {//현재 우선순위와 큐에서 뽑은 것이 같지 않은 경우,      list.offer(temp); //다시 뒤에 넣어줘야한다.즉 이것은 뽑은 것이 현재 우선순위와 같을때까지 해준다.     M = (M == 0) ? list.size() - 1 : --M;//내가 찾고자 하는 문서는 앞으로 한칸씩 이동할 것이다.     //만약 0인경우 -1을 할경우 리스트의 맨 뒤로 오기 때문에 list.size() -1을 해준다.   } else {//현재 우선순위와 큐에서 뽑은 것이 같은 경우     cur--;//다음 우선순위 볼 것이므로(오름차순 정렬으로 --을 해준다.)     answer++;//우선순위 높은 것이 출력된 것이므로 +1을 해준다.     if (M == 0) {//내가 찾고자하는 위치가 0이라는 것은 내가 찾고자 하는것이 출력되는 것.        System.out.println(answer);//결과 출력하고 끝 !       break;     } else {       M--;//아니면 위치 변경, 위에서 M != 0임이 확정이므로, 그냥 --해주면 된다.     }   } }                기억해야 할 것!!!!!!       M = (M == 0) ? list.size() - 1 : --M; //if else 가 한줄에 된다. 신기하다. 다음에 꼭 써먹어 보도록 ‼️           느낀점   이 문제는 3번째 푸는데도 어려운 문제다….ㅋㅋㅋㅋ그래도 맨 처음 풀었을 때에 비해서는 더 효율적으로 짠거 같다. 그리고 두번째랑은 코드가 아주 유사하다. 심지어 그때가 더 나은거 같기도..난 왜이렇게 이문제가 어려운걸까..다음에 풀때도 어려울지 궁금하다 ㅎㅅㅎ 다음에 풀때는 한번에 풀어내고 싶다 . !      문제 : https://www.acmicpc.net/problem/1966     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/026b0406353454d35f3766b4f156b30c59e6f46d/Algorithm/1.BOJ/Q_1966_프린터큐_0203.java   ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","STACK"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ1966_%ED%94%84%EB%A6%B0%ED%84%B0%ED%81%90/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ2529-부등호",
        "excerpt":"문제   두 종류의 부등호 기호 ‘&lt;’와 ‘&gt;’가 k개 나열된 순서열  A가 있다. 우리는 이 부등호 기호 앞뒤에 서로 다른 한 자릿수 숫자를 넣어서 모든 부등호 관계를 만족시키려고 한다. 예를 들어, 제시된 부등호 순서열 A가 다음과 같다고 하자.   A =&gt;  &lt; &lt; &lt; &gt; &lt; &lt; &gt; &lt; &gt;   부등호 기호 앞뒤에 넣을 수 있는 숫자는 0부터 9까지의 정수이며 선택된 숫자는 모두 달라야 한다. 아래는 부등호 순서열 A를 만족시키는 한 예이다.   3 &lt; 4 &lt; 5 &lt; 6 &gt; 1 &lt; 2 &lt; 8 &gt; 7 &lt; 9 &gt; 0   이 상황에서 부등호 기호를 제거한 뒤, 숫자를 모두 붙이면 하나의 수를 만들 수 있는데 이 수를 주어진 부등호 관계를 만족시키는 정수라고 한다. 그런데 주어진 부등호 관계를 만족하는 정수는 하나 이상 존재한다. 예를 들어 3456128790 뿐만 아니라 5689023174도 아래와 같이 부등호 관계 A를 만족시킨다.   5 &lt; 6 &lt; 8 &lt; 9 &gt; 0 &lt; 2 &lt; 3 &gt; 1 &lt; 7 &gt; 4   여러분은 제시된 k개의 부등호 순서를 만족하는 (k+1)자리의 정수 중에서 최댓값과 최솟값을 찾아야 한다. 앞서 설명한 대로 각 부등호의 앞뒤에 들어가는 숫자는 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }중에서 선택해야 하며 선택된 숫자는 모두 달라야 한다.   입력   첫 줄에 부등호 문자의 개수를 나타내는 정수 k가 주어진다. 그 다음 줄에는 k개의 부등호 기호가 하나의 공백을 두고 한 줄에 모두 제시된다. k의 범위는 2 ≤ k ≤ 9 이다.   출력   여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력에 답은 항상 존재하며 출력 정수는 하나의 문자열이 되도록 해야 한다.   예제 입력 1   2 &lt; &gt;    예제 출력 1   897 021   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Collections;  public class Main {     static int size;     static String[] input;     static ArrayList&lt;String&gt; resultArr = new ArrayList&lt;&gt;();     public static void main(String[] args) throws Exception{         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         size = Integer.parseInt(bufferedReader.readLine());         input = bufferedReader.readLine().split(\" \");          boolean[] visited = new boolean[10];          String result = \"\";         DFS(0, visited, result );         Collections.sort(resultArr);         System.out.println(resultArr.get(resultArr.size()-1));         System.out.println(resultArr.get(0));      }      public static void DFS(int depth, boolean[] visited, String result){         if (size+1 == depth){             for (int i = 0; i &lt; input.length; i++){                 if (input[i].equals(\"&lt;\")){                     if (!(result.charAt(i) &lt; result.charAt(i+1))) return;                 }else {                     if (!(result.charAt(i) &gt; result.charAt(i+1))) return;                 }             }             resultArr.add(result);             return;         }          for (int i = 0; i &lt;= 9; i++){             if (!visited[i]){                 visited[i] = true;                 DFS(depth + 1, visited, result + i);                 visited[i] = false;             }         }     } }           나는 모든 순열을 먼저 구했다.       순열과 조합의 차이 - 서로 다른 공 5개 : 1 2 3 4 5 중 3개를 뽑는다고 할 때 - 순열: 서로 다른 공 5개중 임의로 3개 뽑아서 순서대로 나열을 하는 것이다.   (135를 뽑았다면 -&gt; 135/ 315/ 513/ 153/ 351/ 531) - 조합은 공을 뽑은 것으로 끝이 난다. 즉, 순열은 뽑은 다음에 순서를 생각해야 하지만 조합은 뽑기만 하면 된다.           왜냐하면 1 2 3과 3 2 1과는 다르기 때문에            순열을 구하는 코드       public static void DFS(int depth, boolean[] visited, String result){   if (size+1 == depth){//순열이 부등호에 조합하는지 확인 !     for (int i = 0; i &lt; input.length; i++){       if (input[i].equals(\"&lt;\")){         if (!(result.charAt(i) &lt; result.charAt(i+1))) return;       }else {         if (!(result.charAt(i) &gt; result.charAt(i+1))) return;       }     }     resultArr.add(result);     return;   }        for (int i = 0; i &lt;= 9; i++){// 각 부등호의 앞뒤에 들어가는 숫자는 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }때문.     if (!visited[i]){       visited[i] = true; //‼️       DFS(depth + 1, visited, result + i);       visited[i] = false; //‼️     }   } }                나온 순열의 중에서 부등호가 맞는 순열을 고르는 부분       if (size+1 == depth){   for (int i = 0; i &lt; input.length; i++){     if (input[i].equals(\"&lt;\")){       if (!(result.charAt(i) &lt; result.charAt(i+1))) return;     }else {       if (!(result.charAt(i) &gt; result.charAt(i+1))) return;     }   }                부등호에 맞는 순열을 고른 후, 최댓값과 최솟값을 구해야 하기 때문에       순열들을 다 list에 저장해서 정렬를 해주었다. 그리고 최소와 최대를 출력해주었다.       느낀점      문제 : https://www.acmicpc.net/problem/2529     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_2529_부등호.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ2529_%EB%B6%80%EB%93%B1%ED%98%B8/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ6603-로또",
        "excerpt":"문제   독일 로또는 {1, 2, …, 49}에서 수 6개를 고른다.   로또 번호를 선택하는데 사용되는 가장 유명한 전략은 49가지 수 중 k(k&gt;6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다.   예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. ([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], …, [3,5,8,13,21,34])   집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.   입력   입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 &lt; k &lt; 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.   입력의 마지막 줄에는 0이 하나 주어진다.   출력   각 테스트 케이스마다 수를 고르는 모든 방법을 출력한다. 이때, 사전 순으로 출력한다.   각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.   예제 입력 1   7 1 2 3 4 5 6 7 8 1 2 3 5 8 13 21 34 0   예제 출력 1   1 2 3 4 5 6 1 2 3 4 5 7 1 2 3 4 6 7 1 2 3 5 6 7 1 2 4 5 6 7 1 3 4 5 6 7 2 3 4 5 6 7  1 2 3 5 8 13 1 2 3 5 8 21 1 2 3 5 8 34 1 2 3 5 13 21 1 2 3 5 13 34 1 2 3 5 21 34 1 2 3 8 13 21 1 2 3 8 13 34 1 2 3 8 21 34 1 2 3 13 21 34 1 2 5 8 13 21 1 2 5 8 13 34 1 2 5 8 21 34 1 2 5 13 21 34 1 2 8 13 21 34 1 3 5 8 13 21 1 3 5 8 13 34 1 3 5 8 21 34 1 3 5 13 21 34 1 3 8 13 21 34 1 5 8 13 21 34 2 3 5 8 13 21 2 3 5 8 13 34 2 3 5 8 21 34 2 3 5 13 21 34 2 3 8 13 21 34 2 5 8 13 21 34 3 5 8 13 21 34   나의 코드   import java.io.InputStreamReader; import java.util.Scanner;  public class Main {     static int lotto = 6;     public static void main(String[] args) throws Exception {         Scanner scanner = new Scanner(new InputStreamReader(System.in));         int size = -1;         while ((size = scanner.nextInt()) != 0){             int[] map = new int[size];             int[] result = new int[lotto];              for (int i = 0; i &lt; size; i++){                 map[i] = scanner.nextInt();             }              DFS(0, 0, map, result);             System.out.println();         }     }      public static void DFS(int start, int depth, int[] map, int[]result){         if (depth == lotto){             for (int i = 0; i &lt; lotto; i++){                 System.out.print(result[i] + \" \");             }             System.out.println();             return;         }          for (int i = start; i &lt; map.length; i++){             result[depth] = map[i];             DFS(i+1, depth+1, map, result);         }     } }           우선 출력 결과를 보면       //입력 7 1 2 3 4 5 6 7    //출력 1 2 3 4 5 6 1 2 3 4 5 7 1 2 3 4 6 7 1 2 3 5 6 7 1 2 4 5 6 7 1 3 4 5 6 7 2 3 4 5 6 7           중복이 없다  그리고 사전순이다       따라서, visited는 사용할 필요가 없다. 만약 12345 와 12354 둘이 다르면 visited를 사용해야 겠지만.       그리고, 맨 뒤에것들끼리 보면 값이 바뀌는 것이 DFS로 접근 했다는 것을 알 수 있다.(나는 그렇게 생각했다 !)       123456을 보고 다음 123457이렇게 탐색 !            depth변수는 지금까지 글자수라고 생각하면 쉽다. 그 숫자가 로또의 숫자 수만큼이 되면 출력을 해주는 것이다.       if (depth == lotto){   for (int i = 0; i &lt; lotto; i++){     System.out.print(result[i] + \" \");   }   System.out.println();   return; }                전체 완전 탐색은 이런식으로 이루어진다.       for (int i = start; i &lt; map.length; i++){   result[depth] = map[i]; //결과의 마지막에 맵의 값을 하나씩 넣어준다.   DFS(i+1, depth+1, map, result); }           예를 들어) 1234567이 있을 때,  start 가 5면,  123456 보고, for문이기 때문에 123457 이렇게 탐색을 하는 것이다 !       느낀점   사실 이 문제는 100퍼센트 이해하지는 못한거 같다. 그때도 너무 어려웠고, 이번에도 긴가민가 풀어서 돌렸는데 답이 나온 것이다. 중복이 없다는 것, 사전 정렬이라는 것이 핵심인 거 같다.      문제 : https://www.acmicpc.net/problem/6603     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_6603_로또_0204.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ6603_%EB%A1%9C%EB%98%90/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ14888-연산자끼워넣기",
        "excerpt":"문제   N개의 수로 이루어진 수열 A1, A2, …, AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.   우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.   예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.      1+2+3-4×5÷6   1÷2+3+4-5×6   1+2÷3×4-5+6   1÷2×3-4+5+6   식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.      1+2+3-4×5÷6 = 1   1÷2+3+4-5×6 = 12   1+2÷3×4-5+6 = 5   1÷2×3-4+5+6 = 7   N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.   출력   첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.   예제 입력 1   2 5 6 0 0 1 0   예제 출력 1   30 30   예제 입력 2   3 3 4 5 1 0 1 0   예제 출력 2   35 17   예제 입력 3   6 1 2 3 4 5 6 2 1 1 1   예제 출력 3   54 -24   힌트   세 번째 예제의 경우에 다음과 같은 식이 최댓값/최솟값이 나온다.      최댓값: 1-2÷3+4+5×6   최솟값: 1+2+3÷4-5×6   나의 코드   import java.io.InputStreamReader; import java.util.Scanner;  public class Main {     static char[] operators = {'+', '-', '*', '/'};     static int N;     static int[] operand;     static int maxAnswer = Integer.MIN_VALUE;     static int minAnswer = Integer.MAX_VALUE;      public static void main(String[] args) {         Scanner scanner = new Scanner(new InputStreamReader(System.in));         N = scanner.nextInt();         operand = new int[N];          for (int i = 0; i &lt; N; i++) {             operand[i] = scanner.nextInt();         }          char[] operator = new char[N - 1];         int index = 0;         for (int i = 0; i &lt; 4; i++) {             int number = scanner.nextInt();             for (int j = 0; j &lt; number; j++) {                 operator[index++] = operators[i];             }         }          boolean[] visited = new boolean[N - 1];         String result = \"\";         Permutation(0, operator, visited, result);          System.out.println(maxAnswer);         System.out.println(minAnswer);     }      public static void Permutation(int depth, char[] operator, boolean[] visited, String result) {         if (depth == N - 1) {             minAnswer = Math.min(minAnswer, Calculation(operand, result));             maxAnswer = Math.max(maxAnswer, Calculation(operand, result));              return;         }          for (int i = 0; i &lt; operator.length; i++) {             if (!visited[i]) {                 visited[i] = true;                 Permutation(depth + 1, operator, visited, result + operator[i]);                 visited[i] = false;             }         }     }      public static int Calculation(int[] operand, String operator) {         int result = operand[0];         for (int i = 0; i &lt; operator.length(); i++) {             char curOper = operator.charAt(i);              switch (curOper) {                 case '+':                     result += operand[i + 1];                     break;                 case '-':                     result -= operand[i + 1];                     break;                 case '*':                     result *= operand[i + 1];                     break;                 case '/':                     result /= operand[i + 1];                     break;             }         }         return result;     } }           내가 접근한 방식은 연산자의 순열을 다 만들어서 계산을 해 본다음,  가장 큰 값과, 가장 작은 값을 꺼내는 것이다.            연산자 순열 코드       public static void Permutation(int depth, char[] operator, boolean[] visited, String result) {   if (depth == N - 1) {     minAnswer = Math.min(minAnswer, Calculation(operand, result));     maxAnswer = Math.max(maxAnswer, Calculation(operand, result));        return;   }        for (int i = 0; i &lt; operator.length; i++) {     if (!visited[i]) {       visited[i] = true;       Permutation(depth + 1, operator, visited, result + operator[i]);       visited[i] = false;     }   } }           느낀점   어제 부등호 문제를 풀어서 그런지 쉽게 풀 수 있었다.      문제 : https://www.acmicpc.net/problem/14888     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/3.SWEA/Q_14888_연산자끼워넣기.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","DFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ14888_%EC%97%B0%EC%82%B0%EC%9E%90%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0/",
        "teaser":null},{
        "title": "[ALGORITHM]PROGRAMMERS_DFS/BFS_타겟넘버",
        "excerpt":"문제   n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.   -1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3   사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.   제한사항      주어지는 숫자의 개수는 2개 이상 20개 이하입니다.   각 숫자는 1 이상 50 이하인 자연수입니다.   타겟 넘버는 1 이상 1000 이하인 자연수입니다.   입출력 예                  numbers       target       return                       [1, 1, 1, 1, 1]       3       5           #####   나의 코드   class Solution {     int answer = 0;     int mtarget = 0;      public int solution(int[] numbers, int target) {         mtarget = target;         DFS(0, 0, numbers, 0);          return answer;     }      public void DFS(int start, int depth, int[] numbers, int result) {         if (depth == numbers.length) {             if (result == mtarget) {                 answer++;             }         }          for (int i = start; i &lt; numbers.length; i++) {             DFS(i + 1, depth + 1, numbers, result + numbers[i]);             DFS(i + 1, depth + 1, numbers, result - numbers[i]);         }     } }           나는 number들을 맨 앞에서 부터 보면서 + 와 -를 다해봤다.            그리고 그 값이 target과 같으면 answer++를 해주었다.            모든 경우의 수를 다 본다.       public void DFS(int start, int depth, int[] numbers, int result) {   if (depth == numbers.length) {     if (result == mtarget) {       answer++;     }   }      for (int i = start; i &lt; numbers.length; i++) {     DFS(i + 1, depth + 1, numbers, result + numbers[i]);//+     DFS(i + 1, depth + 1, numbers, result - numbers[i]);//-   } }           즉, 12가 있으면       -1  --&gt; +2 / -2  +1  --&gt; +2 / -2           이렇게 해준다. !       모든 순열을 보는 것 이 아니라 visited도 필요없는 경우다 !       느낀점      문제 : https://programmers.co.kr/learn/courses/30/lessons/43165#     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/2.PROGRAMMERS/DFS:BFS_타겟넘버.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","PROGRAMMERS","DFS"],
        "url": "http://localhost:4000/algorithm/Algorithms-Programmers_DFS-BFS_%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84/",
        "teaser":null},{
        "title": "[ALGORITHM]BOJ5052_전화번호목록",
        "excerpt":"문제   전화번호 목록이 주어진다. 이때, 이 목록이 일관성이 있는지 없는지를 구하는 프로그램을 작성하시오.   전화번호 목록이 일관성을 유지하려면, 한 번호가 다른 번호의 접두어인 경우가 없어야 한다.   예를 들어, 전화번호 목록이 아래와 같은 경우를 생각해보자      긴급전화: 911   상근: 97 625 999   선영: 91 12 54 26   이 경우에 선영이에게 전화를 걸 수 있는 방법이 없다. 전화기를 들고 선영이 번호의 처음 세 자리를 누르는 순간 바로 긴급전화가 걸리기 때문이다. 따라서, 이 목록은 일관성이 없는 목록이다.   입력   첫째 줄에 테스트 케이스의 개수 t가 주어진다. (1 ≤ t ≤ 50) 각 테스트 케이스의 첫째 줄에는 전화번호의 수 n이 주어진다. (1 ≤ n ≤ 10000) 다음 n개의 줄에는 목록에 포함되어 있는 전화번호가 하나씩 주어진다. 전화번호의 길이는 길어야 10자리이며, 목록에 있는 두 전화번호가 같은 경우는 없다.   출력   각 테스트 케이스에 대해서, 일관성 있는 목록인 경우에는 YES, 아닌 경우에는 NO를 출력한다.   예제 입력 1   2 3 911 97625999 91125426 5 113 12340 123440 12345 98346   예제 출력 1   NO YES   #####   나의 코드   import java.io.BufferedReader; import java.io.InputStreamReader;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         int t = Integer.parseInt(bufferedReader.readLine());          while (t-- &gt; 0) {             int size = Integer.parseInt(bufferedReader.readLine());             String[] arr = new String[size];             for (int i = 0; i &lt; size; i++){                  arr[i] = bufferedReader.readLine();             }             if (CheckContain(arr, size)) System.out.println(\"YES\");             else System.out.println(\"NO\");         }     }      public static boolean CheckContain(String[] arr, int size){         for (int i = 0; i &lt; size-1; i++){             for (int j = i+1; j &lt; size; j++){                 if (arr[j].startsWith(arr[i]) || arr[i].startsWith(arr[j])){                     return false;                 }             }         }         return true;     } }           시간 초과가 난 코드이다.            모든 단어들을 일일이 다 비교를 했다.       public static boolean CheckContain(String[] arr, int size){   for (int i = 0; i &lt; size-1; i++){     for (int j = i+1; j &lt; size; j++){       if (arr[j].startsWith(arr[i]) || arr[i].startsWith(arr[j])){         return false;       }     }   }   return true; }                예를들면       911 97625999 91125426    인 경우, 911 과 97625999 비교, 911와 91125426 비교. 97625999와 91125426를 비교한다.           이 경우 아무래도 시간복잡도가 높아 시간초과가 난거 같다.       import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.Arrays;  public class Main {     public static void main(String[] args) throws Exception {         BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));         int t = Integer.parseInt(bufferedReader.readLine());          while (t-- &gt; 0) {             int size = Integer.parseInt(bufferedReader.readLine());             String[] arr = new String[size];             for (int i = 0; i &lt; size; i++){                 arr[i] = bufferedReader.readLine();             }             Arrays.sort(arr);              if (CheckContain(arr, size)) System.out.println(\"YES\");             else System.out.println(\"NO\");         }     }      public static boolean CheckContain(String[] arr, int size){         for (int i = 0; i &lt; size-1; i++){             String cur = arr[i];             String next = arr[i+1];             if (cur.startsWith(next) || next.startsWith(cur)) return false;         }         return true;     } }           다시 짜본 코드는 이러하다.            일일이 비교를 하는 것이 아니라, 비교를 하기 전에 사전순으로 정렬을 하였다.            //input 91125426 12340 123440 911    //String 정렬 👉 사전순 정렬 12340 123440 911 91125426    //int 정렬 👉 정수의 크기 오름차순 911 12340 123440 91125426                사전순으로 정렬을 하게 되면, 다음 것만 확인을 하면 된다.            따라서,            public static boolean CheckContain(String[] arr, int size){   for (int i = 0; i &lt; size-1; i++){     String cur = arr[i];     String next = arr[i+1];     if (cur.startsWith(next) || next.startsWith(cur)) return false;   }   return true; }           //input 91125426 12340 123440 911    //String 정렬 👉 사전순 정렬 12340 123440 911 91125426    12340과 123440비교 -&gt; ❌ 123440과 911비교 -&gt; ❌ 911과 91123426비교 -&gt; ⭕️ 이런식으로 찾는 것이다.           메소드 비교   내가 이것저거 해본 메소드 비교이다.      ✔️ equals(): 문자열 비교 메소드이다. 양 쪽에 있는 내용을 비교한 값을 true/false로 반환한다.                 이 문제에서 equals를 사용하려면,         String str1 = \"911\"; String str2 = \"91125426\";    if (str1.equals(str2.substring(0,str1.length()))) System.out.println(\"YES\"); else System.out.println(\"NO\");               이런식으로 사용해야 한다. 하지만 문자열의 길이의 차이로 오류가 날 수 있으니 코드를 좀 더 추가해야한다 !             ✔️ contains()                 이 문제에서 contains()를 사용하려면,         String str1 = \"911\"; String str2 = \"91125426\";    if (str1.contains(str2.substring(0,str1.length()))) System.out.println(\"YES\"); else System.out.println(\"NO\");                   ✔️ startsWith()                 내가 이 문제에서 이것을 사용한 이유는 문자열 범위를 정해주지 않아도 된다는 이유에서 이것을 사용하였다.                  문자열의 시작부분봐 지정한 문자열이 일치하는지 확인해준다.                  String str1 = \"911\"; String str2 = \"91125426\";    if (str2.startsWith(str1)) System.out.println(\"YES\"); else System.out.println(\"NO\");                   느낀점      문제 : https://www.acmicpc.net/problem/5052     저장소 : https://github.com/yoo-chaewon/HELLO_JAVA/blob/master/Algorithm/1.BOJ/Q_5052_전화번호목록.java    ","categories": ["ALGORITHM"],
        "tags": ["ALGORITHM","BOJ","Hash"],
        "url": "http://localhost:4000/algorithm/Algorithms-BOJ5052_%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8%EB%AA%A9%EB%A1%9D/",
        "teaser":null}]
